<html>
  <head>
    <title>ht.auto()</title>
    <link href="themes/prism.css" rel="stylesheet" />
    <script src="libs/prism.js"></script>
    <script src="bundle.js"></script>
  </head>
  <body style="margin: 0; color: #333; font-family: sans-serif; overflow: hidden;">
    <div style="max-width: 800px; margin: 0 auto; background: #eee; height: 100%; padding: 0 1em; position: relative; overflow: auto;">
      <br />
      <br />
      <br />
      <div style="border-bottom: 5px dashed;">
        <h2 style="text-align: center;">METAHEAP</h2>
      </div>
      <h1 style="text-align: center;">ht.auto()</h1>
      <h2>AUTO is group consensus among peers. it functions like the <a href="https://raft.github.io/" target="_blank">RAFT</a> consensus algorithm under the hood. this algorithm can be used to solve many of the problems that distributed systems present. such as reaching an agreement between a cluster of machines and then assigning tasks out to each one.</h2>
      <pre><code class="language-a">BEEP --> TURN --> MOVE ... AUTO</code></pre>
      <h2>here is <a href="https://github.com/trabur/RAceFasT" target="_blank">code</a> from three node.js servers:</h2>
<pre><code class="language-js">let id1 = '1' // license plate
let network1 = "AEIOUaeiou" // road
let address1 = ht.secret(10, network1)
// --with--
ht.move(id1, address1)
ht.auto.new(id1, { address: address1 })

ht.auto.on(id1, 'term change', (to, from) => {
  console.log('were now running on term %s -- was %s', to, from)
}).on('leader change', function (to, from) {
  console.log('we have a new leader to: %s -- was %s', to, from)
}).on('state change', function (to, from) {
  console.log('we have a state to: %s -- was %s', to, from)
})
</code></pre>
<pre><code class="language-js">let id2 = '2' // license plate
let network2 = "AEIOUaeiou" // road
let address2 = ht.secret(10, network2)
// --with--
ht.move(id2, address2)
ht.auto.new(id2, { address: address2 })
ht.auto.join(id2, address1)
</code></pre>
<pre><code class="language-js">let id3 = '3' // license plate
let network3 = "AEIOUaeiou" // road
let address3 = ht.secret(10, network3)
// --with--
ht.move(id3, address3)
ht.auto.new(id3, { address: address3 })
ht.auto.join(id3, address1)
ht.auto.join(id3, address2)
// --or--
ht.move(id3, address3).auto.new({ address: address3 }).join(address1).join(address2)
</code></pre>
<pre><code class="language-css">// mobile: start...
// lane: transporting...
// listen: AEIOUaeiou
// beep: AEIOUaeiou
// beep: HONK
</code></pre>
      <ul style="font-size: 1.8em; font-family: monospace;">
        <li><a href="/ht.auto.on.html">ht.auto.on()</a></li>
        <li><a href="/ht.auto.new.html">ht.auto.new()</a></li>
        <li><a href="/ht.auto.join.html">ht.auto.join()</a></li>
        <li><a href="/ht.auto.leave.html">ht.auto.leave()</a></li>
        <li><a href="/ht.auto.packet.html">ht.auto.packet()</a></li>
        <li><a href="/ht.auto.command.html">ht.auto.command()</a></li>
      </ul>
      <h2>after a group of peers reach consensus the next natural thing to do is use INTERSECTION by load-balancing traffic to it or use SECRET by confusing the situation around it. this is required because with physics matter can not be created or destroyed.</h2>
      <h2>we have no true destroy. therefore, if we want to "delete" something we must make it difficult to access; push it away by distance or delay it by time.</h2>
      <h2>we have no true create. therefore, if we want to "make" something we must deal with the situation at hand; switch traffic lights between red, green, and yellow.</h2>
      <h1 style="text-align: center;"><a href="/">UPWARD</a> (:</h1>
      <div style="border-top: 5px dashed;">
        <h2 style="text-align: center;">METAHEAP</h2>
      </div>
      <br />
      <br />
      <br />
    </div>
  </body>
</html>