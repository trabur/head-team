<html>
  <head>
    <title>ht.auto()</title>
    <link href="themes/prism.css" rel="stylesheet" />
    <script src="libs/prism.js"></script>
    <!-- GUN -->
    <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/radix.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/radisk.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/store.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/rindexed.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/sea.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/webrtc.js"></script>
    <!-- HT -->
    <script src="bundle.js"></script>
  </head>
  <body style="margin: 0; color: #333; font-family: sans-serif; overflow: hidden;">
    <div style="max-width: 800px; margin: 0 auto; background: #eee; height: 100%; padding: 0 1em; position: relative; overflow: auto;">
      <br />
      <br />
      <br />
      <div style="border-bottom: 5px dashed;">
        <h2 style="text-align: center;">METAHEAP</h2>
      </div>
      <h1 style="text-align: center;">ht.auto()</h1>
      <h2>AUTO is group consensus among peers. it functions like the <a href="https://raft.github.io/" target="_blank">RAFT</a> consensus algorithm; for distributed systems. however it functions best in situations where a system of multi layering is possible. such as reaching an agreement between peers in a single group; then reaching futher agreement between other groups.</h2>
      <pre><code class="language-a">BEEP --> TURN --> MOVE ... AUTO</code></pre>
      <h2>checkout our full <a href="https://github.com/trabur/RAceFasT" target="_blank">code</a> example which best demonstrates how simple GCAP is. for AUTO to function it relies on storage to keep record of what is happening between each machine in the group; among peers. to LOG these records we use GUN as the underlying database where further distributed wiring can happen. final topology outcome depends on the RELAYVISOR's ability to init, run, and maintain each layer of the system.</h2>
<pre><code class="language-js">let gun = new Gun({
  fleetgrid: {
    library: ht, // pass in headteam for gun to use
    token: '...' // use ht.checkpoint() to get this
  }
})
let gun1 = gun.get('metaheap.io').get('fred')
let gun2 = gun.get('metaheap.io').get('bob')
let gun3 = gun.get('metaheap.io').get('chad')
// --layer--
let physical = 'packet...mile-marker'
</code></pre>
      <h2>with the browser's console use the above 1-3 gun instances with the below blocks of code to see how AUTO connects three machines in a cluster together.</h2>
<pre><code class="language-js">let id1 = '1' // license plate
let network1 = "AEIOUaeiou" // road
let address1 = `${id1}...${ht.secret(10, network1)}`
// --with--
ht.move(id1, address1)
ht.auto(id1, { log: gun1, address: address1 })
</code></pre>
<pre><code class="language-js">let id2 = '2' // license plate
let network2 = "AEIOUaeiou" // road
let address2 = `${id2}...${ht.secret(10, network2)}`
// --with--
ht.move(id2, address2)
ht.auto(id2, { log: gun2, address: address2 })
ht.peer.join(id2, address1)
</code></pre>
<pre><code class="language-js">let id3 = '3' // license plate
let network3 = "AEIOUaeiou" // road
let address3 = `${id3}...${ht.secret(10, network3)}`
// --with--
ht.move(id3, address3)
ht.auto(id3, { log: gun3, address: address3 })
ht.peer.join(id3, address1)
ht.peer.join(id3, address2)
// --or--
ht.move(id3, address3)
  .auto({ log: gun3, address: address3 })
  .join(address1)
  .join(address2)
</code></pre>
    <h2>database commands grow stronger when needed in order to compensate for fault tolerance; this includes any scrutinizing, harassing, trolling, and the like. think of CLICK, SCROLL, POINTER (CSP) as being yet another alternative to BEEP, TURN, MOVE (BTM). there is also SPEAK, STEP, WALK (SSW); i bring up three examples here to help demonstrate how AUTO functions in a multi layering system such as the code from our 3 machine cluster above.</h2>
<pre><code class="language-css">// mobile: start...
// lane: transporting...
// listen: AEIOUaeiou
// beep: AEIOUaeiou
// beep: HONK
</code></pre>
      <ul style="font-size: 1.8em; font-family: monospace;">
        <li><a href="/ht.peer.html#join">ht.peer.join()</a></li>
        <li><a href="/ht.peer.html#leave">ht.peer.leave()</a></li>
        <li><a href="/ht.peer.html#command">ht.peer.command()</a></li>
        <li><a href="/ht.peer.html#on">ht.peer.on()</a></li>
      </ul>
      <h2>after consensus the next natural thing to do is use INTERSECTION by load-balancing traffic to it or use SECRET by confusing the situation around it. this is required because with physics matter can not be created or destroyed.</h2>
      <h2>we have no true destroy. therefore, if we want to "remove" something we must make it difficult to access; push it away by distance or delay it by time.</h2>
      <h2>we have no true create. therefore, if we want to "make" something we must deal with the situation at hand; switch traffic lights between red, green, and yellow.</h2>
      <h1 style="text-align: center;"><a href="/">UPWARD</a> (:</h1>
      <div style="border-top: 5px dashed;">
        <h2 style="text-align: center;">METAHEAP</h2>
      </div>
      <br />
      <br />
      <br />
    </div>
  </body>
</html>